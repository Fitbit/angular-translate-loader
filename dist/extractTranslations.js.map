{"version":3,"sources":["../src/extractTranslations.js"],"names":["MODULE_EXPORTS","parseJson","value","JSON","parse","isModule","test","extractFromModule","matches","match","length","toString","convertValue","result","Error","findValue","loaderContext","content","Buffer","Array","isArray","inputValue","options","rawValue","err","emitError","namespaces","key"],"mappings":";;;;;;AAAA;;AAKA;;AAGA;;AAGA;;;;;;AAEA;;;;AAIA,IAAMA,iBAAiB,0CAAvB;;AAEA;;;;;AAKA,SAASC,SAAT,CAAmBC,KAAnB,EAA0B;AACtB,WAAOC,KAAKC,KAAL,CAAW,8BAAYF,KAAZ,CAAX,CAAP;AACH;;AAED;;;;AAIA,SAASG,QAAT,CAAkBH,KAAlB,EAAyB;AACrB,WAAO,sBAASA,KAAT,KAAmBF,eAAeM,IAAf,CAAoBJ,KAApB,CAA1B;AACH;;AAED;;;;AAIA,SAASK,iBAAT,CAA2BL,KAA3B,EAAkC;AAC9B,QAAMM,UAAUN,MAAMO,KAAN,CAAYT,cAAZ,CAAhB;AAAA,QACIS,QAAQD,QAAQE,MAAR,IAAkB,CAAlB,GAAsBF,QAAQ,CAAR,EAAWG,QAAX,EAAtB,GAA8C,IAD1D;;AAGA,WAAOV,UAAUQ,KAAV,CAAP;AACH;;AAED;;;;AAIA,SAASG,YAAT,CAAsBV,KAAtB,EAA6B;AACzB,QAAIW,eAAJ;;AAEA,QAAIR,SAASH,KAAT,CAAJ,EAAqB;AACjBW,iBAASN,kBAAkBL,KAAlB,CAAT;AACH,KAFD,MAEO,IAAI,sBAASA,KAAT,CAAJ,EAAqB;AACxBW,iBAASZ,UAAUC,KAAV,CAAT;AACH,KAFM,MAEA,IAAI,sBAASA,KAAT,CAAJ,EAAqB;AACxBW,iBAASX,KAAT;AACH;;AAED,QAAI,CAAC,sBAASW,MAAT,CAAL,EAAuB;AACnB,cAAM,IAAIC,KAAJ,iEAAN;AACH;;AAED,WAAOD,MAAP;AACH;;AAED;;;;;AAKA,SAASE,SAAT,CAAmBC,aAAnB,EAAkCC,OAAlC,EAA2C;AACvC,QAAIf,cAAJ;;AAEA,QAAI,sBAASe,OAAT,CAAJ,EAAuB;AACnBf,gBAAQe,OAAR;AACH,KAFD,MAEO,IAAIA,mBAAmBC,MAAvB,EAA+B;AAClChB,gBAAQe,QAAQN,QAAR,EAAR;AACH,KAFM,MAEA,IAAIQ,MAAMC,OAAN,CAAcJ,cAAcK,UAA5B,CAAJ,EAA6C;AAChDnB,gBAAQc,cAAcK,UAAd,CAAyB,CAAzB,CAAR;AACH,KAFM,MAEA,IAAI,sBAASL,cAAcd,KAAvB,CAAJ,EAAmC;AACtCA,gBAAQc,cAAcd,KAAtB;AACH,KAFM,MAEA;AACHA,gBAAQe,OAAR;AACH;;AAED,WAAOf,KAAP;AACH;;AAED;;;;;;;kBAMe,UAACc,aAAD,EAAgBC,OAAhB,EAAyBK,OAAzB,EAAqC;AAChD,QAAMC,WAAWR,UAAUC,aAAV,EAAyBC,OAAzB,CAAjB;;AAEA,QAAIf,cAAJ;;AAEA,QAAI;AACAA,gBAAQU,aAAaW,QAAb,CAAR;AACH,KAFD,CAEE,OAAMC,GAAN,EAAW;AACTR,sBAAcS,SAAd,CAAwBD,GAAxB;AACH;;AAED,QAAME,aAAa,qCAAsBV,aAAtB,EAAqCd,KAArC,EAA4CoB,OAA5C,CAAnB;;AAEA,WAAO,qBAAQpB,KAAR,EAAe,UAACA,KAAD,EAAQyB,GAAR;AAAA,eAAgBD,aAAaC,GAA7B;AAAA,KAAf,CAAP;AACH,C","file":"extractTranslations.js","sourcesContent":["import {\r\n    isObject,\r\n    isString,\r\n    mapKeys\r\n} from 'lodash';\r\nimport {\r\n    parseString\r\n} from 'loader-utils';\r\nimport {\r\n    name\r\n} from '../package.json';\r\nimport interpolateNamespaces from './interpolateNamespaces';\r\n\r\n/**\r\n * @private\r\n * @type {RegExp}\r\n */\r\nconst MODULE_EXPORTS = /module\\.exports\\s?=\\s?({[\\s\\S\\n\\t]+?});?/;\r\n\r\n/**\r\n * @private\r\n * @param {String} value\r\n * @return {Object}\r\n */\r\nfunction parseJson(value) {\r\n    return JSON.parse(parseString(value));\r\n}\r\n\r\n/**\r\n * @param {String} value\r\n * @return {Boolean}\r\n */\r\nfunction isModule(value) {\r\n    return isString(value) && MODULE_EXPORTS.test(value);\r\n}\r\n\r\n/**\r\n * @param {String} value\r\n * @return {Object}\r\n */\r\nfunction extractFromModule(value) {\r\n    const matches = value.match(MODULE_EXPORTS),\r\n        match = matches.length >= 1 ? matches[1].toString() : '{}';\r\n\r\n    return parseJson(match);\r\n}\r\n\r\n/**\r\n * @param {String} value\r\n * @return {Object}\r\n */\r\nfunction convertValue(value) {\r\n    let result;\r\n\r\n    if (isModule(value)) {\r\n        result = extractFromModule(value);\r\n    } else if (isString(value)) {\r\n        result = parseJson(value);\r\n    } else if (isObject(value)) {\r\n        result = value;\r\n    }\r\n\r\n    if (!isObject(result)) {\r\n        throw new Error(`\"${name}\" loader only accepts 'Object' value.`);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * @param {*} loaderContext\r\n * @param {String} content\r\n * @returns {*}\r\n */\r\nfunction findValue(loaderContext, content) {\r\n    let value;\r\n\r\n    if (isString(content)) {\r\n        value = content;\r\n    } else if (content instanceof Buffer) {\r\n        value = content.toString();\r\n    } else if (Array.isArray(loaderContext.inputValue)) {\r\n        value = loaderContext.inputValue[0];\r\n    } else if (isString(loaderContext.value)) {\r\n        value = loaderContext.value;\r\n    } else {\r\n        value = content;\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * @param {*} loaderContext\r\n * @param {*} content\r\n * @param {Object} options\r\n * @returns {Object}\r\n */\r\nexport default (loaderContext, content, options) => {\r\n    const rawValue = findValue(loaderContext, content);\r\n\r\n    let value;\r\n\r\n    try {\r\n        value = convertValue(rawValue);\r\n    } catch(err) {\r\n        loaderContext.emitError(err);\r\n    }\r\n\r\n    const namespaces = interpolateNamespaces(loaderContext, value, options);\r\n\r\n    return mapKeys(value, (value, key) => namespaces + key);\r\n};\r\n"]}